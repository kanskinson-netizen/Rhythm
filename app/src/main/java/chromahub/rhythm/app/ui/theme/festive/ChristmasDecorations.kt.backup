package chromahub.rhythm.app.ui.theme.festive

import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.rotate
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import kotlin.math.PI
import kotlin.math.cos
import kotlin.math.sin
import kotlin.random.Random

/**
 * Complete Christmas decorations including lights, candies, and snow collection
 */
@Composable
fun ChristmasDecorations(
    intensity: Float = 0.5f,
    modifier: Modifier = Modifier
) {
    Box(modifier = modifier.fillMaxSize()) {
        // Top Christmas lights - below status bar
        Box(
            modifier = Modifier
                .align(Alignment.TopCenter)
                .padding(top = 40.dp)
        ) {
            ChristmasLights(intensity = intensity)
        }
        
        // Side decorations (candies and ornaments)
        SideDecorations(intensity = intensity)
        
        // Bottom snow collection - anchored to bottom
        Box(
            modifier = Modifier.align(Alignment.BottomCenter)
        ) {
            SnowCollection(intensity = intensity)
        }
    }
}

/**
 * Christmas lights string at the top
 */
@Composable
fun ChristmasLights(
    intensity: Float = 0.5f,
    modifier: Modifier = Modifier
) {
    val configuration = LocalConfiguration.current
    val density = LocalDensity.current
    val screenWidth = with(density) { configuration.screenWidthDp.dp.toPx() }
    
    // Blinking animation for lights
    val infiniteTransition = rememberInfiniteTransition(label = "lights")
    val blinkPhase by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 2000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "blinkPhase"
    )
    
    // Generate light positions
    val lights = remember(screenWidth, intensity) {
        val count = (screenWidth / 80f * (0.5f + intensity * 0.5f)).toInt().coerceIn(8, 20)
        List(count) { index ->
            val x = (screenWidth / count) * index + (screenWidth / count / 2)
            val colorIndex = index % 4
            val color = when (colorIndex) {
                0 -> Color(0xFFFF4444) // Red
                1 -> Color(0xFF44FF44) // Green
                2 -> Color(0xFFFFFF44) // Yellow
                3 -> Color(0xFF4444FF) // Blue
                else -> Color.White
            }
            Triple(x, color, index * 90f) // x, color, phase offset
        }
    }
    
    Canvas(modifier = modifier.fillMaxWidth().height(60.dp)) {
        // Draw wavy wire/string
        val wireY = 40f
        val waveAmplitude = 8f
        val waveFrequency = 3f
        val path = Path().apply {
            moveTo(0f, wireY)
            var x = 0f
            while (x <= size.width) {
                val y = wireY + sin((x / size.width) * waveFrequency * 2 * PI).toFloat() * waveAmplitude
                lineTo(x, y)
                x += 10f
            }
        }
        
        drawPath(
            path = path,
            color = Color(0xFF2C5530).copy(alpha = 0.6f),
            style = androidx.compose.ui.graphics.drawscope.Stroke(width = 3f)
        )
        
        // Draw lights hanging from wavy wire
        lights.forEach { (x, color, phaseOffset) ->
            val brightness = (sin((blinkPhase + phaseOffset) * PI / 180) * 0.3f + 0.7f).toFloat()
            val wireYAtX = wireY + sin((x / size.width) * waveFrequency * 2 * PI).toFloat() * waveAmplitude
            
            // Wire connection
            drawLine(
                color = Color(0xFF2C5530).copy(alpha = 0.6f),
                start = Offset(x, wireYAtX),
                end = Offset(x, wireYAtX + 15f),
                strokeWidth = 2f
            )
            
            // Light bulb
            drawCircle(
                color = color.copy(alpha = brightness),
                radius = 12f,
                center = Offset(x, wireYAtX + 25f)
            )
            
            // Glow effect
            drawCircle(
                color = color.copy(alpha = brightness * 0.3f),
                radius = 18f,
                center = Offset(x, wireYAtX + 25f)
            )
        }
    }
}

/**
 * Side decorations - Simple ornaments and garland style
 */
@Composable
fun SideDecorations(
    intensity: Float = 0.5f,
    modifier: Modifier = Modifier
) {
    val configuration = LocalConfiguration.current
    val density = LocalDensity.current
    val screenHeight = with(density) { configuration.screenHeightDp.dp.toPx() }
    
    // Gentle sway animation
    val infiniteTransition = rememberInfiniteTransition(label = "sideDecorations")
    val sway by infiniteTransition.animateFloat(
        initialValue = -8f,
        targetValue = 8f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 2500, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "sway"
    )
    
    // Generate simple ornament decorations
    val decorations = remember(screenHeight, intensity) {
        val count = (5 + (intensity * 3).toInt()).coerceIn(5, 8)
        val startY = 180f
        val endY = screenHeight - 300f
        val spacing = (endY - startY) / (count - 1)
        
        List(count) { index ->
            val y = startY + (spacing * index)
            val size = 0.8f + Random.nextFloat() * 0.4f // Size variation 0.8-1.2
            val colorIndex = index % 5
            val color = when (colorIndex) {
                0 -> Color(0xFFE63946) // Red
                1 -> Color(0xFFFFD700) // Gold
                2 -> Color(0xFF2A9D8F) // Teal/Green
                3 -> Color(0xFF4169E1) // Blue
                4 -> Color(0xFFDC143C) // Crimson
                else -> Color(0xFFFF6B6B)
            }
            Triple(y, size, color)
        }
    }
    
    Canvas(modifier = modifier.fillMaxSize()) {
        val leftX = 15f
        val rightX = size.width - 15f
        
        // Left side - vertical garland with ornaments
        drawVerticalGarland(leftX, 150f, screenHeight - 280f, sway)
        decorations.forEach { (y, scale, color) ->
            val swayOffset = sway * (0.5f + scale * 0.5f)
            drawSimpleOrnament(
                Offset(leftX + swayOffset, y),
                color,
                scale
            )
        }
        
        // Right side - vertical garland with ornaments
        drawVerticalGarland(rightX, 150f, screenHeight - 280f, -sway)
        decorations.forEachIndexed { index, (y, scale, _) ->
            val colorIndex = (index + 2) % 5
            val color = when (colorIndex) {
                0 -> Color(0xFFE63946)
                1 -> Color(0xFFFFD700)
                2 -> Color(0xFF2A9D8F)
                3 -> Color(0xFF4169E1)
                4 -> Color(0xFFDC143C)
                else -> Color(0xFFFF6B6B)
            }
            val swayOffset = -sway * (0.5f + scale * 0.5f)
            drawSimpleOrnament(
                Offset(rightX + swayOffset, y),
                color,
                scale
            )
        }
    }
}

/**
 * Draw a vertical garland strand
 */
private fun DrawScope.drawVerticalGarland(x: Float, startY: Float, endY: Float, sway: Float) {
    val segments = 30
    val path = Path()
    path.moveTo(x, startY)
    
    for (i in 0..segments) {
        val progress = i.toFloat() / segments
        val y = startY + (endY - startY) * progress
        val swayAmount = sin(progress * PI * 4).toFloat() * 8f + sway * 0.3f
        path.lineTo(x + swayAmount, y)
    }
    
    // Dark green garland strand
    drawPath(
        path = path,
        color = Color(0xFF1B4332),
        style = androidx.compose.ui.graphics.drawscope.Stroke(width = 3f)
    )
}

/**
 * Draw a simple ornament ball
 */
private fun DrawScope.drawSimpleOrnament(center: Offset, color: Color, scale: Float = 1f) {
    val radius = 12f * scale
    
    // Main ornament ball with gradient
    drawCircle(
        brush = Brush.radialGradient(
            colors = listOf(
                color.copy(alpha = 1f),
                color.copy(alpha = 0.8f)
            ),
            center = Offset(center.x - radius * 0.3f, center.y - radius * 0.3f),
            radius = radius
        ),
        radius = radius,
        center = center
    )
    
    // Shine effect
    drawCircle(
        color = Color.White.copy(alpha = 0.5f),
        radius = 4f * scale,
        center = Offset(center.x - radius * 0.4f, center.y - radius * 0.4f)
    )
    
    // Subtle outline
    drawCircle(
        color = color.copy(alpha = 0.5f),
        radius = radius,
        center = center,
        style = androidx.compose.ui.graphics.drawscope.Stroke(width = 0.5f)
    )
}
    val stringLength: Float
)

// Decoration types enum
private enum class DecoType {
    CANDY_CANE, RED_ORNAMENT, GINGERBREAD, GOLD_ORNAMENT,
    SNOWFLAKE, BELL, STAR, STOCKING
}

/**
 * Draw any decoration type
 */
private fun DrawScope.drawDecoration(center: Offset, type: DecoType, rotation: Float, scale: Float) {
    when (type) {
        DecoType.CANDY_CANE -> drawCandyCane(center, rotation, scale)
        DecoType.RED_ORNAMENT -> drawOrnament(center, rotation, Color(0xFFE63946), scale)
        DecoType.GINGERBREAD -> drawGingerbread(center, rotation, scale)
        DecoType.GOLD_ORNAMENT -> drawOrnament(center, rotation, Color(0xFFFFD700), scale)
        DecoType.SNOWFLAKE -> drawSnowflakeDecoration(center, rotation, scale)
        DecoType.BELL -> drawBell(center, rotation, scale)
        DecoType.STAR -> drawStar(center, rotation, scale)
        DecoType.STOCKING -> drawStocking(center, rotation, scale)
    }
}


/**
 * Draw a candy cane
 */
private fun DrawScope.drawCandyCane(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val width = 10f * scale
        
        // Background (white base)
        val path = Path().apply {
            moveTo(center.x, center.y + 25f * scale)
            lineTo(center.x, center.y - 12f * scale)
            // Hook at top
            addArc(
                oval = androidx.compose.ui.geometry.Rect(
                    center.x - 10f * scale,
                    center.y - 22f * scale,
                    center.x + 10f * scale,
                    center.y - 2f * scale
                ),
                startAngleDegrees = 0f,
                sweepAngleDegrees = 180f
            )
        }
        
        // White background
        drawPath(
            path = path,
            color = Color.White,
            style = androidx.compose.ui.graphics.drawscope.Stroke(width = width)
        )
        
        // Red stripes overlay
        for (i in 0..8) {
            val segmentY = center.y + 25f * scale - (i * 6f * scale)
            if (i % 2 == 0) {
                drawLine(
                    color = Color(0xFFE63946),
                    start = Offset(center.x - width/2, segmentY),
                    end = Offset(center.x + width/2, segmentY),
                    strokeWidth = 5f * scale
                )
            }
        }
    }
}

/**
 * Draw a Christmas ornament
 */
private fun DrawScope.drawOrnament(center: Offset, rotation: Float, color: Color, scale: Float = 1f) {
    rotate(rotation, center) {
        val radius = 15f * scale
        
        // String
        drawLine(
            color = Color(0xFF2C5530),
            start = Offset(center.x, center.y - radius),
            end = Offset(center.x, center.y - radius - 12f * scale),
            strokeWidth = 2.5f * scale
        )
        
        // Top cap (metallic look)
        val capHeight = 7f * scale
        drawRect(
            brush = Brush.linearGradient(
                colors = listOf(Color(0xFFFFD700), Color(0xFFFFA500)),
                start = Offset(center.x - 5f * scale, center.y - radius),
                end = Offset(center.x + 5f * scale, center.y - radius)
            ),
            topLeft = Offset(center.x - 5f * scale, center.y - radius),
            size = androidx.compose.ui.geometry.Size(10f * scale, capHeight)
        )
        
        // Ornament ball with gradient
        drawCircle(
            brush = Brush.radialGradient(
                colors = listOf(color, color.copy(alpha = 0.7f)),
                center = Offset(center.x - radius * 0.3f, center.y - radius * 0.3f),
                radius = radius
            ),
            radius = radius,
            center = center
        )
        
        // Multiple shine effects
        drawCircle(
            color = Color.White.copy(alpha = 0.6f),
            radius = 6f * scale,
            center = Offset(center.x - radius * 0.4f, center.y - radius * 0.4f)
        )
        drawCircle(
            color = Color.White.copy(alpha = 0.3f),
            radius = 3f * scale,
            center = Offset(center.x + radius * 0.3f, center.y - radius * 0.2f)
        )
    }
}

/**
 * Draw a gingerbread man
 */
private fun DrawScope.drawGingerbread(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val brown = Color(0xFF8B4513)
        val icing = Color(0xFFFFFAFA)
        
        // Body
        drawCircle(
            color = brown,
            radius = 14f * scale,
            center = center
        )
        
        // Head
        drawCircle(
            color = brown,
            radius = 10f * scale,
            center = Offset(center.x, center.y - 18f * scale)
        )
        
        // Arms
        drawCircle(
            color = brown,
            radius = 6f * scale,
            center = Offset(center.x - 18f * scale, center.y)
        )
        drawCircle(
            color = brown,
            radius = 6f * scale,
            center = Offset(center.x + 18f * scale, center.y)
        )
        
        // Legs
        drawCircle(
            color = brown,
            radius = 6f * scale,
            center = Offset(center.x - 7f * scale, center.y + 18f * scale)
        )
        drawCircle(
            color = brown,
            radius = 6f * scale,
            center = Offset(center.x + 7f * scale, center.y + 18f * scale)
        )
        
        // Eyes
        drawCircle(
            color = Color(0xFF2C1810),
            radius = 2.5f * scale,
            center = Offset(center.x - 3.5f * scale, center.y - 19f * scale)
        )
        drawCircle(
            color = Color(0xFF2C1810),
            radius = 2.5f * scale,
            center = Offset(center.x + 3.5f * scale, center.y - 19f * scale)
        )
        
        // Smile
        drawArc(
            color = Color(0xFF2C1810),
            startAngle = 0f,
            sweepAngle = 180f,
            useCenter = false,
            topLeft = Offset(center.x - 4f * scale, center.y - 16f * scale),
            size = androidx.compose.ui.geometry.Size(8f * scale, 4f * scale),
            style = androidx.compose.ui.graphics.drawscope.Stroke(width = 1.5f * scale)
        )
        
        // Buttons (white icing)
        drawCircle(
            color = icing,
            radius = 2.5f * scale,
            center = Offset(center.x, center.y - 5f * scale)
        )
        drawCircle(
            color = icing,
            radius = 2.5f * scale,
            center = Offset(center.x, center.y + 3f * scale)
        )
        
        // Bow tie
        drawCircle(
            color = Color(0xFFE63946),
            radius = 3f * scale,
            center = Offset(center.x, center.y - 13f * scale)
        )
    }
}

/**
 * Draw a snowflake decoration
 */
private fun DrawScope.drawSnowflakeDecoration(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val armLength = 15f * scale
        val iceBlue = Color(0xFFB8E6F0)
        
        // Draw 6 arms
        for (i in 0..5) {
            val angle = (i * 60f + rotation) * PI / 180
            val endX = center.x + cos(angle).toFloat() * armLength
            val endY = center.y + sin(angle).toFloat() * armLength
            
            // Main arm
            drawLine(
                color = iceBlue,
                start = center,
                end = Offset(endX, endY),
                strokeWidth = 2.5f * scale
            )
            
            // Side branches
            val midX = center.x + cos(angle).toFloat() * armLength * 0.6f
            val midY = center.y + sin(angle).toFloat() * armLength * 0.6f
            val branchLength = 5f * scale
            
            val leftAngle = (angle + 45 * PI / 180)
            drawLine(
                color = iceBlue,
                start = Offset(midX, midY),
                end = Offset(
                    midX + cos(leftAngle).toFloat() * branchLength,
                    midY + sin(leftAngle).toFloat() * branchLength
                ),
                strokeWidth = 1.5f * scale
            )
            
            val rightAngle = (angle - 45 * PI / 180)
            drawLine(
                color = iceBlue,
                start = Offset(midX, midY),
                end = Offset(
                    midX + cos(rightAngle).toFloat() * branchLength,
                    midY + sin(rightAngle).toFloat() * branchLength
                ),
                strokeWidth = 1.5f * scale
            )
        }
        
        // Center
        drawCircle(
            color = iceBlue,
            radius = 3f * scale,
            center = center
        )
    }
}

/**
 * Draw a Christmas bell
 */
private fun DrawScope.drawBell(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val goldColor = Color(0xFFFFD700)
        
        // Bell body - trapezoid shape
        val path = Path().apply {
            moveTo(center.x - 10f * scale, center.y - 12f * scale)
            lineTo(center.x + 10f * scale, center.y - 12f * scale)
            lineTo(center.x + 14f * scale, center.y + 10f * scale)
            lineTo(center.x - 14f * scale, center.y + 10f * scale)
            close()
        }
        
        drawPath(
            path = path,
            brush = Brush.linearGradient(
                colors = listOf(goldColor, Color(0xFFDAA520)),
                start = Offset(center.x - 14f * scale, center.y),
                end = Offset(center.x + 14f * scale, center.y)
            )
        )
        
        // Top bow/ribbon
        drawRect(
            color = Color(0xFFE63946),
            topLeft = Offset(center.x - 8f * scale, center.y - 18f * scale),
            size = androidx.compose.ui.geometry.Size(16f * scale, 6f * scale)
        )
        
        // Clapper
        drawCircle(
            color = Color(0xFFDAA520),
            radius = 4f * scale,
            center = Offset(center.x, center.y + 14f * scale)
        )
        
        // Shine
        drawCircle(
            color = Color.White.copy(alpha = 0.5f),
            radius = 4f * scale,
            center = Offset(center.x - 6f * scale, center.y - 4f * scale)
        )
    }
}

/**
 * Draw a Christmas star
 */
private fun DrawScope.drawStar(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val outerRadius = 16f * scale
        val innerRadius = 7f * scale
        val goldColor = Color(0xFFFFD700)
        
        val path = Path()
        for (i in 0 until 10) {
            val angle = (i * 36f - 90f) * PI / 180
            val radius = if (i % 2 == 0) outerRadius else innerRadius
            val x = center.x + cos(angle).toFloat() * radius
            val y = center.y + sin(angle).toFloat() * radius
            
            if (i == 0) {
                path.moveTo(x, y)
            } else {
                path.lineTo(x, y)
            }
        }
        path.close()
        
        // Star with gradient
        drawPath(
            path = path,
            brush = Brush.radialGradient(
                colors = listOf(Color(0xFFFFFF00), goldColor),
                center = center,
                radius = outerRadius
            )
        )
        
        // Outline
        drawPath(
            path = path,
            color = Color(0xFFDAA520),
            style = androidx.compose.ui.graphics.drawscope.Stroke(width = 1.5f * scale)
        )
        
        // Center sparkle
        drawCircle(
            color = Color.White.copy(alpha = 0.7f),
            radius = 3f * scale,
            center = center
        )
    }
}

/**
 * Draw a Christmas stocking
 */
private fun DrawScope.drawStocking(center: Offset, rotation: Float, scale: Float = 1f) {
    rotate(rotation, center) {
        val redColor = Color(0xFFE63946)
        
        // Stocking leg (vertical part)
        drawRect(
            color = redColor,
            topLeft = Offset(center.x - 8f * scale, center.y - 18f * scale),
            size = androidx.compose.ui.geometry.Size(16f * scale, 25f * scale)
        )
        
        // Stocking foot (horizontal part)
        drawRect(
            color = redColor,
            topLeft = Offset(center.x - 8f * scale, center.y + 7f * scale),
            size = androidx.compose.ui.geometry.Size(20f * scale, 10f * scale)
        )
        
        // White trim at top
        drawRect(
            color = Color.White,
            topLeft = Offset(center.x - 8f * scale, center.y - 18f * scale),
            size = androidx.compose.ui.geometry.Size(16f * scale, 5f * scale)
        )
        
        // White trim at foot
        drawRect(
            color = Color.White,
            topLeft = Offset(center.x - 8f * scale, center.y + 7f * scale),
            size = androidx.compose.ui.geometry.Size(20f * scale, 3f * scale)
        )
        
        // Decorative pattern (stripes)
        drawLine(
            color = Color.White.copy(alpha = 0.6f),
            start = Offset(center.x - 8f * scale, center.y - 8f * scale),
            end = Offset(center.x + 8f * scale, center.y - 8f * scale),
            strokeWidth = 2f * scale
        )
        drawLine(
            color = Color.White.copy(alpha = 0.6f),
            start = Offset(center.x - 8f * scale, center.y + 2f * scale),
            end = Offset(center.x + 8f * scale, center.y + 2f * scale),
            strokeWidth = 2f * scale
        )
    }
}

/**
 * Snow collection at the bottom
 */
@Composable
fun SnowCollection(
    intensity: Float = 0.5f,
    modifier: Modifier = Modifier
) {
    val configuration = LocalConfiguration.current
    val density = LocalDensity.current
    val screenWidth = with(density) { configuration.screenWidthDp.dp.toPx() }
    
    // Generate snow pile pattern
    val snowPile = remember(screenWidth, intensity) {
        val points = 50
        List(points) { index ->
            val x = (screenWidth / points) * index
            val baseHeight = 30f + (intensity * 40f)
            val variation = (sin((index.toFloat() / points) * PI * 4) * 15f).toFloat()
            Offset(x, baseHeight + variation)
        }
    }
    
    Canvas(
        modifier = modifier
            .fillMaxWidth()
            .height((80f + intensity * 40f).dp)
    ) {
        // Draw snow pile
        val path = Path().apply {
            moveTo(0f, size.height)
            snowPile.forEach { point ->
                lineTo(point.x, size.height - point.y)
            }
            lineTo(size.width, size.height)
            close()
        }
        
        drawPath(
            path = path,
            brush = Brush.verticalGradient(
                colors = listOf(
                    Color(0xFFFFFAFA),
                    Color(0xFFF0F8FF)
                )
            )
        )
        
        // Add sparkles on snow
        val sparkleCount = (screenWidth / 100f * intensity).toInt()
        repeat(sparkleCount) { index ->
            val x = Random.nextFloat() * size.width
            val y = size.height - (30f + Random.nextFloat() * 40f * intensity)
            
            // Small sparkle
            drawCircle(
                color = Color.White.copy(alpha = 0.8f),
                radius = 2f,
                center = Offset(x, y)
            )
            
            // Glow
            drawCircle(
                color = Color(0xFFE0F2FF).copy(alpha = 0.4f),
                radius = 4f,
                center = Offset(x, y)
            )
        }
    }
}
